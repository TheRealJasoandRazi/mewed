{"ast":null,"code":"import _slicedToArray from \"/Users/nemanjapopovic/Desktop/mewed/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/Users/nemanjapopovic/Desktop/mewed/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/nemanjapopovic/Desktop/mewed/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/nemanjapopovic/Desktop/mewed/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"horizontal\", \"factor\", \"offset\", \"speed\", \"sticky\"],\n  _excluded2 = [\"pages\", \"innerStyle\", \"config\", \"enabled\", \"horizontal\", \"children\"];\n// src/index.tsx\nimport * as React from \"react\";\nimport { useContext, useState, useRef, useEffect } from \"react\";\nimport { useMemoOne, useOnce, raf } from \"@react-spring/shared\";\nimport { a, Controller, config as configs } from \"@react-spring/web\";\nvar ParentContext = React.createContext(null);\nfunction getScrollType(horizontal) {\n  return horizontal ? \"scrollLeft\" : \"scrollTop\";\n}\nfunction mapChildrenRecursive(children, callback) {\n  var isReactFragment = function isReactFragment(node) {\n    if (node.type) {\n      return node.type === React.Fragment;\n    }\n    return node === React.Fragment;\n  };\n  return React.Children.map(children, function (child) {\n    return isReactFragment(child) ? mapChildrenRecursive(child.props.children, callback) : callback(child);\n  });\n}\nvar START_TRANSLATE_3D = \"translate3d(0px,0px,0px)\";\nvar START_TRANSLATE = \"translate(0px,0px)\";\nvar ParallaxLayer = React.memo(React.forwardRef(function (_ref, ref) {\n  var _objectSpread2;\n  var horizontal = _ref.horizontal,\n    _ref$factor = _ref.factor,\n    factor = _ref$factor === void 0 ? 1 : _ref$factor,\n    _ref$offset = _ref.offset,\n    offset = _ref$offset === void 0 ? 0 : _ref$offset,\n    _ref$speed = _ref.speed,\n    speed = _ref$speed === void 0 ? 0 : _ref$speed,\n    sticky = _ref.sticky,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  var parent = useContext(ParentContext);\n  var ctrl = useMemoOne(function () {\n    var translate;\n    if (sticky) {\n      var start = sticky.start || 0;\n      translate = start * parent.space;\n    } else {\n      var targetScroll = Math.floor(offset) * parent.space;\n      var distance = parent.space * offset + targetScroll * speed;\n      translate = -(parent.current * speed) + distance;\n    }\n    return new Controller({\n      space: sticky ? parent.space : parent.space * factor,\n      translate: translate\n    });\n  }, []);\n  var layer = useMemoOne(function () {\n    return {\n      horizontal: horizontal === void 0 || sticky ? parent.horizontal : horizontal,\n      sticky: void 0,\n      isSticky: false,\n      setPosition: function setPosition(height, scrollTop) {\n        var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (sticky) {\n          setSticky(height, scrollTop);\n        } else {\n          var targetScroll = Math.floor(offset) * height;\n          var distance = height * offset + targetScroll * speed;\n          ctrl.start({\n            translate: -(scrollTop * speed) + distance,\n            config: parent.config,\n            immediate: immediate\n          });\n        }\n      },\n      setHeight: function setHeight(height) {\n        var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        ctrl.start({\n          space: sticky ? height : height * factor,\n          config: parent.config,\n          immediate: immediate\n        });\n      }\n    };\n  }, []);\n  useOnce(function () {\n    if (sticky) {\n      var start = sticky.start || 0;\n      var end = sticky.end || start + 1;\n      layer.sticky = {\n        start: start,\n        end: end\n      };\n    }\n  });\n  React.useImperativeHandle(ref, function () {\n    return layer;\n  });\n  var layerRef = useRef();\n  var setSticky = function setSticky(height, scrollTop) {\n    var start = layer.sticky.start * height;\n    var end = layer.sticky.end * height;\n    var isSticky = scrollTop >= start && scrollTop <= end;\n    if (isSticky === layer.isSticky) return;\n    layer.isSticky = isSticky;\n    var ref2 = layerRef.current;\n    ref2.style.position = isSticky ? \"sticky\" : \"absolute\";\n    ctrl.set({\n      translate: isSticky ? 0 : scrollTop < start ? start : end\n    });\n  };\n  useOnce(function () {\n    if (parent) {\n      parent.layers.add(layer);\n      parent.update();\n      return function () {\n        parent.layers.delete(layer);\n        parent.update();\n      };\n    }\n  });\n  var translate3d = ctrl.springs.translate.to(layer.horizontal ? function (x) {\n    return \"translate3d(\".concat(x, \"px,0,0)\");\n  } : function (y) {\n    return \"translate3d(0,\".concat(y, \"px,0)\");\n  });\n  return /* @__PURE__ */React.createElement(a.div, _objectSpread(_objectSpread({}, rest), {}, {\n    ref: layerRef,\n    style: _objectSpread((_objectSpread2 = {\n      position: \"absolute\",\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      backgroundSize: \"auto\",\n      backgroundRepeat: \"no-repeat\",\n      willChange: \"transform\"\n    }, _defineProperty(_objectSpread2, layer.horizontal ? \"height\" : \"width\", \"100%\"), _defineProperty(_objectSpread2, layer.horizontal ? \"width\" : \"height\", ctrl.springs.space), _defineProperty(_objectSpread2, \"WebkitTransform\", translate3d), _defineProperty(_objectSpread2, \"msTransform\", translate3d), _defineProperty(_objectSpread2, \"transform\", translate3d), _objectSpread2), rest.style)\n  }));\n}));\nvar Parallax = React.memo(React.forwardRef(function (props, ref) {\n  var _objectSpread3;\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    ready = _useState2[0],\n    setReady = _useState2[1];\n  var pages = props.pages,\n    _innerStyle = props.innerStyle,\n    _props$config = props.config,\n    config = _props$config === void 0 ? configs.slow : _props$config,\n    _props$enabled = props.enabled,\n    enabled = _props$enabled === void 0 ? true : _props$enabled,\n    _props$horizontal = props.horizontal,\n    horizontal = _props$horizontal === void 0 ? false : _props$horizontal,\n    children = props.children,\n    rest = _objectWithoutProperties(props, _excluded2);\n  var containerRef = useRef();\n  var contentRef = useRef();\n  var state = useMemoOne(function () {\n    return {\n      config: config,\n      horizontal: horizontal,\n      busy: false,\n      space: 0,\n      current: 0,\n      offset: 0,\n      controller: new Controller({\n        scroll: 0\n      }),\n      layers: /* @__PURE__ */new Set(),\n      container: containerRef,\n      content: contentRef,\n      update: function update() {\n        return _update();\n      },\n      scrollTo: function scrollTo(offset) {\n        return _scrollTo(offset);\n      },\n      stop: function stop() {\n        return state.controller.stop();\n      }\n    };\n  }, []);\n  useEffect(function () {\n    state.config = config;\n  }, [config]);\n  React.useImperativeHandle(ref, function () {\n    return state;\n  });\n  var _update = function _update() {\n    var container = containerRef.current;\n    if (!container) return;\n    var spaceProp = horizontal ? \"clientWidth\" : \"clientHeight\";\n    state.space = container[spaceProp];\n    var scrollType = getScrollType(horizontal);\n    if (enabled) {\n      state.current = container[scrollType];\n    } else {\n      container[scrollType] = state.current = state.offset * state.space;\n    }\n    var content = contentRef.current;\n    if (content) {\n      var sizeProp = horizontal ? \"width\" : \"height\";\n      content.style[sizeProp] = \"\".concat(state.space * pages, \"px\");\n    }\n    state.layers.forEach(function (layer) {\n      layer.setHeight(state.space, true);\n      layer.setPosition(state.space, state.current, true);\n    });\n  };\n  var _scrollTo = function _scrollTo(offset) {\n    var container = containerRef.current;\n    var scrollType = getScrollType(horizontal);\n    state.offset = offset;\n    state.controller.set({\n      scroll: state.current\n    });\n    state.controller.stop().start({\n      scroll: offset * state.space,\n      config: config,\n      onChange: function onChange(_ref2) {\n        var scroll = _ref2.value.scroll;\n        container[scrollType] = scroll;\n      }\n    });\n  };\n  var onScroll = function onScroll(event) {\n    if (!state.busy) {\n      state.busy = true;\n      state.current = event.target[getScrollType(horizontal)];\n      raf.onStart(function () {\n        state.layers.forEach(function (layer) {\n          return layer.setPosition(state.space, state.current);\n        });\n        state.busy = false;\n      });\n    }\n  };\n  useEffect(function () {\n    return state.update();\n  });\n  useOnce(function () {\n    setReady(true);\n    var onResize = function onResize() {\n      var update2 = function update2() {\n        return state.update();\n      };\n      raf.onFrame(update2);\n      setTimeout(update2, 150);\n    };\n    window.addEventListener(\"resize\", onResize, false);\n    return function () {\n      return window.removeEventListener(\"resize\", onResize, false);\n    };\n  });\n  var overflow = enabled ? {\n    overflowY: horizontal ? \"hidden\" : \"scroll\",\n    overflowX: horizontal ? \"scroll\" : \"hidden\"\n  } : {\n    overflowY: \"hidden\",\n    overflowX: \"hidden\"\n  };\n  return /* @__PURE__ */React.createElement(a.div, _objectSpread(_objectSpread({}, rest), {}, {\n    ref: containerRef,\n    onScroll: onScroll,\n    onWheel: enabled ? state.stop : void 0,\n    onTouchStart: enabled ? state.stop : void 0,\n    style: _objectSpread(_objectSpread({\n      position: \"absolute\",\n      width: \"100%\",\n      height: \"100%\"\n    }, overflow), {}, {\n      WebkitOverflowScrolling: \"touch\",\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D\n    }, rest.style)\n  }), ready && /* @__PURE__ */React.createElement(React.Fragment, null, /* @__PURE__ */React.createElement(a.div, {\n    ref: contentRef,\n    style: _objectSpread((_objectSpread3 = {\n      overflow: \"hidden\",\n      position: \"absolute\"\n    }, _defineProperty(_objectSpread3, horizontal ? \"height\" : \"width\", \"100%\"), _defineProperty(_objectSpread3, horizontal ? \"width\" : \"height\", state.space * pages), _defineProperty(_objectSpread3, \"WebkitTransform\", START_TRANSLATE), _defineProperty(_objectSpread3, \"msTransform\", START_TRANSLATE), _defineProperty(_objectSpread3, \"transform\", START_TRANSLATE_3D), _objectSpread3), props.innerStyle)\n  }, /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, function (child) {\n    return !child.props.sticky && child;\n  }))), /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, function (child) {\n    return child.props.sticky && child;\n  }))));\n}));\nexport { Parallax, ParallaxLayer };","map":{"version":3,"names":["React","useContext","useState","useRef","useEffect","useMemoOne","useOnce","raf","a","Controller","config","configs","ParentContext","createContext","getScrollType","horizontal","mapChildrenRecursive","children","callback","isReactFragment","node","type","Fragment","Children","map","child","props","START_TRANSLATE_3D","START_TRANSLATE","ParallaxLayer","memo","forwardRef","_ref","ref","_objectSpread2","_ref$factor","factor","_ref$offset","offset","_ref$speed","speed","sticky","rest","_objectWithoutProperties","_excluded","parent","ctrl","translate","start","space","targetScroll","Math","floor","distance","current","layer","isSticky","setPosition","height","scrollTop","immediate","arguments","length","undefined","setSticky","setHeight","end","useImperativeHandle","layerRef","ref2","style","position","set","layers","add","update","delete","translate3d","springs","to","x","concat","y","createElement","div","_objectSpread","top","bottom","left","right","backgroundSize","backgroundRepeat","willChange","_defineProperty","Parallax","_objectSpread3","_useState","_useState2","_slicedToArray","ready","setReady","pages","_innerStyle","innerStyle","_props$config","slow","_props$enabled","enabled","_props$horizontal","_excluded2","containerRef","contentRef","state","busy","controller","scroll","Set","container","content","scrollTo","stop","spaceProp","scrollType","sizeProp","forEach","onChange","_ref2","value","onScroll","event","target","onStart","onResize","update2","onFrame","setTimeout","window","addEventListener","removeEventListener","overflow","overflowY","overflowX","onWheel","onTouchStart","width","WebkitOverflowScrolling","WebkitTransform","msTransform","transform","Provider"],"sources":["/Users/nemanjapopovic/Desktop/mewed/node_modules/@react-spring/parallax/src/index.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useContext, useState, useRef, useEffect, CSSProperties } from 'react'\nimport { useMemoOne, useOnce, raf } from '@react-spring/shared'\nimport {\n  a,\n  Controller,\n  SpringConfig,\n  config as configs,\n} from '@react-spring/web'\n\nconst ParentContext = React.createContext<any>(null)\n\nfunction getScrollType(horizontal: boolean) {\n  return horizontal ? 'scrollLeft' : 'scrollTop'\n}\n\nfunction mapChildrenRecursive(\n  children: React.ReactNode,\n  callback: Function\n): React.ReactNode {\n  const isReactFragment = (node: any) => {\n    if (node.type) {\n      return node.type === React.Fragment\n    }\n    return node === React.Fragment\n  }\n\n  return React.Children.map(children, (child: any) =>\n    isReactFragment(child)\n      ? mapChildrenRecursive(child.props.children, callback)\n      : callback(child)\n  )\n}\n\nconst START_TRANSLATE_3D = 'translate3d(0px,0px,0px)'\nconst START_TRANSLATE = 'translate(0px,0px)'\n\nexport interface IParallaxLayer {\n  horizontal: boolean\n  sticky: StickyConfig\n  isSticky: boolean\n  setHeight(height: number, immediate?: boolean): void\n  setPosition(height: number, scrollTop: number, immediate?: boolean): void\n}\n\nexport interface IParallax {\n  config: ConfigProp\n  horizontal: boolean\n  busy: boolean\n  space: number\n  offset: number\n  current: number\n  controller: Controller<{ scroll: number }>\n  layers: Set<IParallaxLayer>\n  container: React.MutableRefObject<any>\n  content: React.MutableRefObject<any>\n  scrollTo(offset: number): void\n  update(): void\n  stop(): void\n}\n\ntype ViewProps = React.ComponentPropsWithoutRef<'div'>\n\ntype StickyConfig = { start?: number; end?: number } | undefined\n\nexport interface ParallaxLayerProps extends ViewProps {\n  horizontal?: boolean\n  /** Size of a page, (1=100%, 1.5=1 and 1/2, ...) */\n  factor?: number\n  /** Determines where the layer will be at when scrolled to (0=start, 1=1st page, ...) */\n  offset?: number\n  /** Shifts the layer in accordance to its offset, values can be positive or negative */\n  speed?: number\n  /** Layer will be sticky between these two offsets, all other props are ignored */\n  sticky?: StickyConfig\n}\n\nexport const ParallaxLayer = React.memo(\n  React.forwardRef<IParallaxLayer, ParallaxLayerProps>(\n    (\n      { horizontal, factor = 1, offset = 0, speed = 0, sticky, ...rest },\n      ref\n    ) => {\n      // Our parent controls our height and position.\n      const parent = useContext<IParallax>(ParentContext)\n\n      // This is how we animate.\n      const ctrl = useMemoOne(() => {\n        let translate\n        if (sticky) {\n          const start = sticky.start || 0\n          translate = start * parent.space\n        } else {\n          const targetScroll = Math.floor(offset) * parent.space\n          const distance = parent.space * offset + targetScroll * speed\n          translate = -(parent.current * speed) + distance\n        }\n        type Animated = { space: number; translate: number }\n        return new Controller<Animated>({\n          space: sticky ? parent.space : parent.space * factor,\n          translate,\n        })\n      }, [])\n\n      // Create the layer.\n      const layer = useMemoOne<IParallaxLayer>(\n        () => ({\n          horizontal:\n            horizontal === undefined || sticky ? parent.horizontal : horizontal,\n          sticky: undefined,\n          isSticky: false,\n          setPosition(height, scrollTop, immediate = false) {\n            if (sticky) {\n              setSticky(height, scrollTop)\n            } else {\n              const targetScroll = Math.floor(offset) * height\n              const distance = height * offset + targetScroll * speed\n              ctrl.start({\n                translate: -(scrollTop * speed) + distance,\n                config: parent.config,\n                immediate,\n              })\n            }\n          },\n          setHeight(height, immediate = false) {\n            ctrl.start({\n              space: sticky ? height : height * factor,\n              config: parent.config,\n              immediate,\n            })\n          },\n        }),\n        []\n      )\n\n      useOnce(() => {\n        if (sticky) {\n          const start = sticky.start || 0\n          const end = sticky.end || start + 1\n          layer.sticky = { start, end }\n        }\n      })\n\n      React.useImperativeHandle(ref, () => layer)\n\n      const layerRef = useRef<any>()\n\n      const setSticky = (height: number, scrollTop: number) => {\n        const start = layer.sticky!.start! * height\n        const end = layer.sticky!.end! * height\n        const isSticky = scrollTop >= start && scrollTop <= end\n\n        if (isSticky === layer.isSticky) return\n        layer.isSticky = isSticky\n\n        const ref = layerRef.current\n        ref.style.position = isSticky ? 'sticky' : 'absolute'\n        ctrl.set({\n          translate: isSticky ? 0 : scrollTop < start ? start : end,\n        })\n      }\n\n      // Register the layer with our parent.\n      useOnce(() => {\n        if (parent) {\n          parent.layers.add(layer)\n          parent.update()\n          return () => {\n            parent.layers.delete(layer)\n            parent.update()\n          }\n        }\n      })\n\n      const translate3d = ctrl.springs.translate.to(\n        layer.horizontal\n          ? x => `translate3d(${x}px,0,0)`\n          : y => `translate3d(0,${y}px,0)`\n      )\n\n      return (\n        <a.div\n          {...rest}\n          ref={layerRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            backgroundSize: 'auto',\n            backgroundRepeat: 'no-repeat',\n            willChange: 'transform',\n            [layer.horizontal ? 'height' : 'width']: '100%',\n            [layer.horizontal ? 'width' : 'height']: ctrl.springs.space,\n            WebkitTransform: translate3d,\n            msTransform: translate3d,\n            transform: translate3d,\n            ...rest.style,\n          }}\n        />\n      )\n    }\n  )\n)\n\ntype ConfigProp = SpringConfig | ((key: string) => SpringConfig)\n\nexport interface ParallaxProps extends ViewProps {\n  /** Determines the total space of the inner content where each page takes 100% of the visible container */\n  pages: number\n  config?: ConfigProp\n  enabled?: boolean\n  horizontal?: boolean\n  innerStyle?: CSSProperties\n  children: React.ReactNode\n}\n\nexport const Parallax = React.memo(\n  React.forwardRef<IParallax, ParallaxProps>((props, ref) => {\n    const [ready, setReady] = useState(false)\n    const {\n      pages,\n      innerStyle: _innerStyle,\n      config = configs.slow,\n      enabled = true,\n      horizontal = false,\n      children,\n      ...rest\n    } = props\n\n    const containerRef = useRef<any>()\n    const contentRef = useRef<any>()\n\n    const state: IParallax = useMemoOne(\n      () => ({\n        config,\n        horizontal,\n        busy: false,\n        space: 0,\n        current: 0,\n        offset: 0,\n        controller: new Controller({ scroll: 0 }),\n        layers: new Set<IParallaxLayer>(),\n        container: containerRef,\n        content: contentRef,\n        update: () => update(),\n        scrollTo: offset => scrollTo(offset),\n        stop: () => state.controller.stop(),\n      }),\n      []\n    )\n\n    useEffect(() => {\n      state.config = config\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [config])\n\n    React.useImperativeHandle(ref, () => state)\n\n    const update = () => {\n      const container = containerRef.current\n      if (!container) return\n\n      const spaceProp = horizontal ? 'clientWidth' : 'clientHeight'\n      state.space = container[spaceProp]\n\n      const scrollType = getScrollType(horizontal)\n      if (enabled) {\n        state.current = container[scrollType]\n      } else {\n        container[scrollType] = state.current = state.offset * state.space\n      }\n\n      const content = contentRef.current\n      if (content) {\n        const sizeProp = horizontal ? 'width' : 'height'\n        content.style[sizeProp] = `${state.space * pages}px`\n      }\n\n      state.layers.forEach(layer => {\n        layer.setHeight(state.space, true)\n        layer.setPosition(state.space, state.current, true)\n      })\n    }\n\n    const scrollTo = (offset: number) => {\n      const container = containerRef.current\n      const scrollType = getScrollType(horizontal)\n\n      state.offset = offset\n\n      state.controller.set({ scroll: state.current })\n      state.controller.stop().start({\n        scroll: offset * state.space,\n        config,\n        onChange({ value: { scroll } }: any) {\n          container[scrollType] = scroll\n        },\n      })\n    }\n\n    const onScroll = (event: any) => {\n      if (!state.busy) {\n        state.busy = true\n        state.current = event.target[getScrollType(horizontal)]\n        raf.onStart(() => {\n          state.layers.forEach(layer =>\n            layer.setPosition(state.space, state.current)\n          )\n          state.busy = false\n        })\n      }\n    }\n\n    useEffect(() => state.update())\n    useOnce(() => {\n      setReady(true)\n\n      const onResize = () => {\n        const update = () => state.update()\n        raf.onFrame(update)\n        setTimeout(update, 150) // Some browsers don't fire on maximize!\n      }\n\n      window.addEventListener('resize', onResize, false)\n      return () => window.removeEventListener('resize', onResize, false)\n    })\n\n    const overflow: React.CSSProperties = enabled\n      ? {\n          overflowY: horizontal ? 'hidden' : 'scroll',\n          overflowX: horizontal ? 'scroll' : 'hidden',\n        }\n      : {\n          overflowY: 'hidden',\n          overflowX: 'hidden',\n        }\n\n    return (\n      <a.div\n        {...rest}\n        ref={containerRef}\n        onScroll={onScroll}\n        onWheel={enabled ? state.stop : undefined}\n        onTouchStart={enabled ? state.stop : undefined}\n        style={{\n          position: 'absolute',\n          width: '100%',\n          height: '100%',\n          ...overflow,\n          WebkitOverflowScrolling: 'touch',\n          WebkitTransform: START_TRANSLATE,\n          msTransform: START_TRANSLATE,\n          transform: START_TRANSLATE_3D,\n          ...rest.style,\n        }}\n      >\n        {ready && (\n          <>\n            <a.div\n              ref={contentRef}\n              style={{\n                overflow: 'hidden',\n                position: 'absolute',\n                [horizontal ? 'height' : 'width']: '100%',\n                [horizontal ? 'width' : 'height']: state.space * pages,\n                WebkitTransform: START_TRANSLATE,\n                msTransform: START_TRANSLATE,\n                transform: START_TRANSLATE_3D,\n                ...props.innerStyle,\n              }}\n            >\n              <ParentContext.Provider value={state}>\n                {mapChildrenRecursive(\n                  children,\n                  (child: any) => !child.props.sticky && child\n                )}\n              </ParentContext.Provider>\n            </a.div>\n            <ParentContext.Provider value={state}>\n              {mapChildrenRecursive(\n                children,\n                (child: any) => child.props.sticky && child\n              )}\n            </ParentContext.Provider>\n          </>\n        )}\n      </a.div>\n    )\n  })\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}